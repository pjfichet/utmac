.\"""""""""""""""""""""""""""""""""""""
.\" idx: Create an index of words.
.\"
.nr idx-trap 0 1
.de idx:trap
.	\" Place an output line trap to get the real page number
.	\" $1 key
.	\" $2 word to index
.	de idx:\\n+[idx-trap]
.		\" Add the trap number to delete the trap later
.		idx:record \\n[idx-trap] \\$*
\\..
.	var:print \\P[idx:\\n[idx-trap]]\\c
..
.ds idx-list
.de idx:record
.	\" Delete previous trap,
.	\" and record an index entry.
.	\" $1 trap number
.	\" $2 keyword
.	\" $3 word
.	lnr idx-previoustrap (\\$1 -1)
.	\" Delete the previous if it exists
.	\" (Traps printed in notes may appear later and are skipped.)
.	if d idx\\n[idx-previoustrap] .rm idx:\\n[idx-previoustrap]
.	lds idx-key \\$2
.	shift 2
.	as idx-list @@@\\*[idx-key]> \\$*:: \\n%
..
.de XI
.	\" Write the index list to a file
.	\" format it, and source it.
.	br
.	ds idx-file /tmp/\\*[data-file].idx.tr
.	\" inconv fixes a bug in heirloom troff
.	sy echo "\\*[idx-list]" | sed -e "s/@@@/\\\\n/g" | iconv -f latin1 -t utf8 > \\*[idx-file]
.	sy idx -d \\*[idx-file] > \\*[idx-file].b
.	so \\*[idx-file].b
.	sy rm \\*[idx-file] \\*[idx-file].b
..
.\"""""""""""""""""""""""""""""""""""""
.\" Format the output of idx
.\" The output of idx is as follow:
.\" .K<			Start an index of type K
.\" .ds P< 		A list of pages
.\" .K> word	The index entry appearing on those pages
.
.de idx:header
.	\" Print an header line (.K<)
.	H3 \\$*
.	\"H* \\$*
.	\"H0 \\$*
.	\"sp 1v
..
.de idx:par
.	br
.	par:init
.	in 3v
.	ti 0
..
.de idx:line
.	\" Print an index entry (.K> word)
.	idx:par
.	var:print \\$*: \\*(<P.
..
.de A<
.	idx:header \\*[lang-Idxa]
..
.de M<
.	idx:header \\*[land-Idxm]
..
.de N<
.	idx:header \\*[lang-Idxn]
..
.de T<
.	idx:header \\*[lang-Idxt]
..
.de U<
.	idx:header \\*[lang-Idxu]
..
.de W<
.	idx:header \\*[lang-Idxw]
..
.als A> idx:line
.als M> idx:line
.als N> idx:line
.als T> idx:line
.als U> idx:line
.als W> idx:line
.\"""""""""""""""""""""""""""""""""""""
.\" User macros
.de LP
.	\" User defined text to print
.	ds idx-text \\$1
.	ds idx-end \\$2
.	ds idx-beg \\$3
..
.de idx:index
.	idx:trap \\$*
.	if d idx-text .var:print \\*[idx-beg]\\*[idx-text]\\*[idx-end]
.	rm idx-text
.	rm idx-end
.	rm idx-beg
..
.de LA
.	idx:index A \\$*
..
.de LM
.	ie \\n[note-in]=0 \{\
.		\" We're not in a note
.		ie d idx-text \{\
.			\" We have substitute text for the mail address
.			\" Print this text, add a note containing the mail
.			pdf:mail \\$1 "\\*[idx-text]" "\\**\\*[idx-end]" "\\*[idx-beg]"
.			NS
.			lang:rchar
.			pdf:mail \\$1 <\\$1>
.			lang:char
.			NE
.		\}
.		el \{\
.			\" We don't have substitute text, print the mail
.			lang:rchar
.			pdf:mail \\$1 <\\$1> \\$2 \\$3
.			lang:char
.		\}
.	\}
.	el \{\
.		\" We're yet in a note
.		ie d idx-text \{\
.			\" We have substitute text for the mail address
.			pdf:mail \\$1 "\\*[idx-text]" "\\**\\*[idx-end]" "\\*[idx-beg]"
.		\}
.		el \{\
.			lang:rchar
.			pdf:mail \\$1 <\\$1> \\$2 \\$3
.			lang:char
.		\}
.	\}
.	rm idx-text
.	rm idx-end
.	rm idx-beg
..
.de LN
.	idx:index N \\$*
..
.de LT
.	idx:index T \\$*
..
.de LU
.	ie \\n[note-in]=0 \{\
.		\" We're not in a note
.		ie d idx-text \{\
.			\" We have substitute text for the url
.			\" Print this text, add a note containing the url
.			pdf:url \\$1 "\\*[idx-text]" "\\**\\*[idx-end]" "\\*[idx-beg]"
.			NS
.			lang:rchar
.			pdf:url \\$1 <\\$1>
.			lang:char
.			NE
.		\}
.		el \{\
.			\" We don't have substitute text, print the url 
.			lang:rchar
.			pdf:url \\$1 <\\$1> "\\$2" "\\$3"
.			lang:char
.		\}
.	\}
.	el \{\
.		\" We're yet in a note
.		ie d idx-text \{\
.			\" We have substitute text for the url
.			pdf:url \\$1 "\\*[idx-text]" "\\*[idx-end]" "\\*[idx-beg]"
.		\}
.		el \{\
.			lang:rchar
.			pdf:url \\$1 <\\$1> "\\$2" "\\$3"
.			lang:char
.		\}
.	\}
.	rm idx-text
.	rm idx-end
.	rm idx-beg
..
.de LW
.	idx:index W \\$*
..
.\"""""""""""""""""""""""""""""""""""""
.\" Anchors and internal links
.\" Those are not indexed, but use the
.\" same syntax of others inline macros
.
.ds idx-file-anchors /tmp/\\*[data-file]-anchors.tr
.nr idx-src-anchors 0
.ds idx-anchors .
.am doc:end
.	\" Record list of anchors in a file
.	sy echo "\\*[idx-anchors]" | sed -e "s/@@@/\\\\n./g" | iconv -f latin1 -t utf8 > \\*[idx-file-anchors]
..
.de idx:anchors
.	\" Retrieve list of anchors from a file
.	if \\n[idx-src-anchors]=0 \{\
.		sy touch \\*[idx-file-anchors]
.		so \\*[idx-file-anchors]
.		nr idx-src-anchors 1
.	\}
..
.de LK
.	\" Print an anchor (keyword) for later reference
.	\" $1: the keyword
.	idx:anchors
.	nr idx-K\\$1 \\n% \" if no break before link
.	de idx:K\\$1
.		\" Output line trap to get the real page number
.		nr idx-K\\$1 \\\\n%
.		\" Record list of page numbers for next pass
.		as idx-anchors @@@nr idx-K\\$1 \\\\n%
\\..
.	var:print \\P[idx:K\\$1]\\c
.	pdf:anchor \\$1 \\c
.	\" And print the text
.	if d idx-text .var:print \\*[idx-beg]\\*[idx-text]\\*[idx-end]
.	rm idx-text
.	rm idx-end
.	rm idx-beg
..
.de LL
.	\" A link to a previously defined anchor
.	\" $1: the keyword
.	if !r idx-K\\$1 \{\
.		\" Anchor should be put later, inform user
.		if \\n(RH .var:tm \\*[lang-wait]Â \\$0 \\$1
.		nr idx-K\\$1 0
.	\}
.	ie \\n[note-in]=0 \{\
.		\" We're not in a note, create one
.		ie d idx-text \{\
.			\" we have replacement text, print it and the note
.			pdf:link \\$1 "\\*[idx-text]" "\\**\\*[idx-end]" "\\*[idx-beg]"
.			NS
.			pdf:link \\$1 "\\*[lang-See] \\*[lang-p]\~\\n[idx-K\\$1]" .
.			NE
.		\}
.		el \{\
.			\" We don't have replacement text
.			pdf:link \\$1 "\\*[lang-see] \\*[lang-p]\~\\n[idx-K\\$1]" ) (
.		\}
.	\}
.	el \{\
.		\" We're in a note, print text in it
.		if d idx-text \{\
.			pdf:link \\$1 "\\*[idx-text]" "\\*[idx-end]" "\\*[idx-beg]"
.		\}
.		pdf:link \\$1 "\\*[lang-See] \\*[lang-p]\~\\n[idx-K\\$1]" .
.	\}
.	rm idx-text
.	rm idx-end
.	rm idx-beg
..
