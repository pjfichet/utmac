.\" u-ref: refer support.
.ig
$Id: u-ref.tmac,v 0.17 2017/12/10 14:14:30 pj Exp $

Copyright (c) 2012
Pierre-Jean Fichet. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the
following conditions are met:

  1. Redistributions of source code must retain the above
     copyright notice, this list of conditions and the
     following disclaimer.
  2. Redistributions in binary form must reproduce the
     above copyright notice, this list of conditions and the
     following disclaimer in the documentation and/or other
     materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
..
.
.
.
.ig
Refer support for heirloom library macros
which respect the iso 690 standart

iso-690 default:

books:   Q A   S V T E B w   U H C I D   P M N O x y z G
journal: Q A T S   V J w N   E U H P C I D M O   x y z G

refer adaptation to iso-690:

book:    Q A E S V T     w     U H   C I D   P M N O x y z G
inbook:  Q A T E S V B   w   P U H   C I D     M N O x y z G
serie:   Q A E S   T     w   P U H   C I D V P M N O x y z G
journal: Q A T S V J     w N E U H P C I D     M   O x y z G
report: like book

With:
	book: E may be the first author
	inbook: T is before E S V B
	serie: V is the total number of volumes

If in serie we use P to define the number of volumes,
serie is like books. Finally, we've got three definitions:

iso--book: Q A E S V T     w     U H   C I D   P M N O x y z G
iso--inbo: Q A T E S V B   w   P U H   C I D     M N O x y z G
iso--jour: Q A T S V J     w N E U H P C I D     M   O x y z G
..
.\"""""""""""""""""""""""""""""""""""""""""""""""
.\" fonts for hrefer
.\"ds C \*C
.\"ds P \*P
.\"""""""""""""""""""""""""""""""""""""""""""""""
.ig
We need to know which punctuation must be used. In some
circumstances, the punctuation is defined by what is before,
in other, it is defined by what is after. The difficult task
is that we want do avoid most of the tests.
By default, punctuation is defined with the field.
But, it may be changed later, with the key:pun macro.
For parenthesis, we use key:beg and key:end macros.

iso--book: Q A E S V T     w     U H   C I D   P M N O x y z G
iso--inbo: Q A T E S V B   w   P U H   C I D     M N O x y z G
iso--jour: Q A T S V J     w N E U H P C I D     M   O x y z G

..
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.nr tmac-u-ref 1
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\" utroff.org refer strings:
.ds +F \\*C
.ds -F \\*C
.ds +L \\*C
.ds -L \\*C
.ds +J
.ds -J
.ds [. \\*U
.ds .] \\*U
.\" usage is to put the dot after the reference:
.ds <.
.ds >. \&.
.\""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.\" Format fields
.\" ref-[position]-[type].
.\"		Position = coll or text.
.\"		Type = 1, 2 or 3.
.\" coll: collected references at the end of a document
.\" text: references written in a note
.\" 1 journal or article
.\" 2 book
.\" 3 article in book
.\"
.\" key:prt print the previous field, and format the current one
.\" key:beg define a parenthesis to put before the next field
.\" key:end define a parenthesis to put after the previous field
.\" key:pun replace the punctuation of the previous field
.\" key:lst print the last field of the reference
.de ref:coll-1
.	\" Collected reference of a journal-article
.	\" Q A T S V J w N E U H P C I D M O x y z G
.	key:prt "" Q "" .
.	key:prt "" A "" .
.	key:prt "\\*I" T "\\*I" .
.	if \\n([A>0 .key:pun
.	key:prt "\\*I" S "\\*I" .
.	key:prt "\\*[lang-Vol]. " V "" :
.	key:prt "«" J "»" .
.	key:pun . \" needed if J is not defined.
.	key:prt "[" w "]" .
.	key:prt "\\*[lang-No]\~" N "" .
.	key:prt "\\*[lang-Dir] " E "" .
.	key:prt "" U "" .
.	key:prt "" H "" .
.	key:prt "\\*[lang-P]\~" P "" .
.	key:prt "" C "" :
.	key:prt "" I "" ,
.	key:prt "" D "" .
.	key:pun . \" needed if I or D are not defined.
.	key:prt "\\*[lang-Col] " M "" .
.	key:prt "" O "" .
.	key:prt "\\*[lang-On] <" x ">" .
.	key:prt "\\*[lang-Update] " y "" .
.	key:prt "\\*[lang-Seen] " z "" .
.	key:prt "\\*[lang-ISBN]: " G "" .
.	key:lst .
..
.de ref:text-1
.	\" In text referece of a journal-article
.	\" Q A T S V J w N E U H P C I D M O x y z G
.	key:prt "" Q "" ,
.	key:prt "" A "" ,
.	key:prt "\\*I" T "\\*I" ,
.	key:prt "\\*I" S "\\*I" ,
.	key:prt "\\*[lang-vol] " V "" :
.	key:prt "«" J "»" ,
.	key:beg (
.	key:prt "\\*[lang-opcit] " % "" ,
.	key:prt "[" w "]" ,
.	key:prt "\\*[lang-no]\~" N "" ,
.	key:prt "\\*[lang-dir] " E "" ,
.	key:prt "" C "" :
.	key:prt "" I "" ,
.	key:prt "" D "" ,
.	key:end )
.	key:pun ,
.	key:prt "" h "" ,
.	key:prt "\\*[lang-p]\~" p "" ,
.	key:beg (
.	key:prt "\\*[lang-on] <" x ">" ,
.	key:prt "\\*[lang-update] " y "" ,
.	key:prt "\\*[lang-seen] " z "" .
.	key:end )
.	key:lst .
..
.\"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
.de ref:coll-3
.	\" Collected reference of an article-in-book
.	\" Q A T E S V B w P U H C I D M N O x y z G
.	key:prt "" Q "" .
.	key:prt "" A "" .
.	if \\n([A>0 .key:pun
.	key:prt "\\*I" T "\\*I" .
.	key:pun ". \\*[lang-In]"
.	key:prt "" E " (\\*[lang-ed\\n([E])" .
.	key:prt "\\*I" S "\\*I" .
.	key:prt "\\*[lang-Vol] " V "" :
.	key:prt "\\*I" B "\\*I" .
.	key:pun . \" needed if B is not defined.
.	key:prt "[" w "]" .
.	key:prt "\\*[lang-P]\~" P "" .
.	key:prt "" U "" .
.	key:prt "" H "" .
.	key:prt "" C "" :
.	key:prt "" I "" ,
.	key:prt "" D "" .
.	key:pun . \" needed if I or D are not defined.
.	key:prt "\\*[lang-Col] " M "" .
.	key:prt "" O "" .
.	key:prt "\\*[lang-On] <" x ">" .
.	key:prt "\\*[lang-Update] " y "" .
.	key:prt "\\*[lang-Seen] " z "" .
.	key:prt "\\*[lang-ISBN]: " G "" .
.	key:lst .
..
.de ref:text-3
.	\" In text reference of an article-in-book
.	\" Q A T E S V B w P U H C I D M N O x y z G
.	key:prt "" Q "" ,
.	key:prt "" A "" ,
.	key:prt "\\*I" T "\\*I" ,
.	key:pun ", \\*[lang-in]"
.	key:prt "" E " (\\*[lang-ed\\n([E])" ,
.	key:prt "\\*I" S "\\*I" ,
.	key:prt "\\*[lang-vol] " V "" :
.	key:prt "\\*I" B "\\*I" ,
.	key:beg (
.	key:prt "\\*[lang-opcit] " % "" ,
.	key:prt "[" w "]" ,
.	key:prt "" C "" :
.	key:prt "" I "" ,
.	key:prt "" D "" ,
.	key:end )
.	key:pun ,
.	key:prt "" h "" ,
.	key:prt "\\*[lang-p]\~" p "" ,
.	key:beg (
.	key:prt "\\*[lang-on] <" x ">" ,
.	key:prt "\\*[lang-update] " y "" ,
.	key:prt "\\*[lang-seen] " z "" .
.	key:end )
.	key:lst .
..
.\"""""""""""""""""""""""""""""""""""""""""""""""
.de ref:coll-2
.	\" Collected reference of a book
.	\" Q A E S V T w U H C I D P M N O x y z G
.	key:prt "" Q "" .
.	key:prt "" A "" .
.	if \\n([A>0 .key:pun
.	key:prt "" E " (\\*[lang-ed\\n([E])" .
.	key:prt "\\*I" S "\\*I" .
.	key:prt "\\*[lang-Vol] " V "" :
.	key:prt "\\*I" T "\\*I" .
.	key:pun .
.	key:prt "[" w "]" .
.	key:prt "" U "" .
.	key:prt "" H "" .
.	key:prt "" C "" :
.	key:prt "" I "" ,
.	key:prt "" D "" .
.	key:pun .
.	key:prt "" P "\~\\*[lang-p]"
.	key:prt "\\*[lang-Col] " M "" .
.	key:prt "" O "" .
.	key:prt "\\*[lang-On] <" x ">" .
.	key:prt "\\*[lang-Update] " y "" .
.	key:prt "\\*[lang-Seen] " z "" .
.	key:prt "\\*[lang-ISBN]: " G "" .
.	key:lst .
..
.de ref:text-2
.	\" In text reference of a book
.	\" Q A E S V T w U H C I D P M N O x y z G
.	key:prt "" Q "" ,
.	key:prt "" A "" ,
.	key:prt "" E " (\\*[lang-ed\\n([E])" ,
.	key:prt "\\*I" S "\\*I" ,
.	key:prt "\\*[lang-vol] " V "" :
.	key:prt "\\*I" T "\\*I" ,
.	key:beg (
.	key:prt "\\*[lang-opcit] " % "" ,
.	key:prt "[" w "]" ,
.	key:prt "" C "" :
.	key:prt "" I "" ,
.	key:prt "" D "" ,
.	key:end )
.	key:pun ,
.	key:prt "" h "" ,
.	key:prt "\\*[lang-p]\~" p "" ,
.	key:beg (
.	key:prt "\\*[lang-on] <" x ">" ,
.	key:prt "\\*[lang-update] " y "" ,
.	key:prt "\\*[lang-seen] " z "" .
.	key:end )
.	key:lst .
..
.\" Other kind of references
.als ref:coll-0 ref:coll-2
.als ref:text-0 ref:text-2
.\" Tech-report references
.als ref:coll-4 ref:coll-2
.als ref:text-4 ref:text-2
.\"""""""""""""""""""""""""""""""""""""""""""""""
.\" Key
.de key:prt
.	\" if the current key is defined by refer,
.	\" format it and print the previously formatted key
.	\" arguments are:
.	\"		$1 string before field
.	\"		$2 field
.	\"		$3 string after field
.	\"		$4 punctuation
.	\"	Strings are:
.	\"		key-beg = defined by key:beg (open a parenthesis)
.	\"		key-end = defined by key:end (close a parenthesis)
.	\"		key-field = $1$2$3
.	\"		key-pun = $4
.	\" The strings are concatenated as follow:
.	\"		\\*[key-beg]\\*[key-field]\\*[key-end]\\*[key-pun]
.	\" So we can change punctuation without changing parenthesis.
.	\" Registers are:
.	\"		key-grp >0 if a field is defined after key-beg
.	\"		key-pun : 0 to disallow change of punctuation
.	if d [\\$2 .if !"\\*([\\$2"" \{\
.		\" Should we write idem?
.		if \\n[ref-idm]>0 .idm:\\*[ref-loc] \\$2
.		if \\n[key-do]>0 \{\
.			if d key-field \{\
.			\" There is a previous field, print it.
.			var:print \\*[key-field]\\*[key-end]\\*[key-pun]
.			\}
.			\" Format the current field
.			ds key-field \\*[key-beg]\\$1\\*([\\$2\\$3
.			\" Record the punctuation
.			ds key-pun \\$4
.			ds key-beg
.			ds key-end
.			nr key-grp +1
.			nr key-pun 1
.		\}
.	\}
..
.de key:lst
.	\" print last key of a reference
.	\" $1: punctuation
.	\" key-pun=0 if key-pun is not allowed 
.	if d key-field \{\
.		\" there is a defined field
.		ie \\n[key-pun]=1 .ds key-pun \\$1
.		el .ds key-pun
.		\" When we don't print the reference inside a note
.		\" we don't want a space after the field, to
.		\" may insert a closing bracket.
.		\" Cf ref:text-start and ref:text-stop
.		if \\n(RN=0 .if '\\*[ref-loc]'text' .ds key-pun \\c
.		var:print \\*[key-field]\\*[key-end]\\*[key-pun]
.	\}
..
.de key:pun
.	\" define key-pun, which contains the punctuation
.	if \\n[key-pun]=1 .ds key-pun \\$*
..
.de key:nopun
.	\" don't allow punctuation
.	nr key-pun 0
.	ds key-pun
..
.de key:beg
.	\" define key-beg, which opens a parenthesis
.	\" and remove punctuation
.	ds key-beg \\$*
.	if \\n[key-pun]=1 .ds key-pun
.	\" There's no field after the parenthesis,
.	\" so key-grp is set to 0
.	nr key-grp 0
..
.de key:end
.	\" define key-end, which closes a parenthesis
.	\" only if there are fields after the parenthesis
.	ds key-beg
.	if \\n[key-grp]>0 .ds key-end \\$*
..
.\"""""""""""""""""""""""""""""""""""""""""""""""
.\" idem
.ig
RI is user defined
ref-idm is initialized at RI for each reference
	O: do not do idem
	1: do idem
	2: idem done
key-do: 1 to print key-field
idm:text replace fields by idem
if not only first field is idem
..
.de idm:num
.	\" set numbers
.	nr ref-idm \\$1
.	nr key-do \\$2
..
.de idm:text
.	\" Current field of the current reference is [X,
.	\" the same field in the previous refence is recored in ]X
.	\" If [X and ]X are equals, we write "idem."
.	\" $1 is the letter field.
.	ie d ]\\$1 \{\
.		lang:rchar \" Needed for string comparison
.		ie "\\*([\\$1"\\*(]\\$1" \{\
.			ie \\n[ref-idm]>1 \{\
.				ds key-field \\*[lang-Ibid]
.				nr key-pun 0
.				ds key-pun ,
.				\"key:nopun
.				ref:remove %
.				idm:num +1 0
.			\}
.			el .idm:num +1 1
.		\}
.		el .idm:num 0 1
.		lang:char
.	\}
.	el .idm:num 0 1
..
.de idm:PB
.	PB
.	idm:num 0 1
..
.de idm:coll
.	\" Same as idm:text for collected references.
.	\" We print a line instead of "idem."
.	ie \\n[ref-idm]=2 .idm:num 0 1
.	el \{\
.	ie d ]\\$1 \{\
.		lang:rchar \" Needed for string comparison
.		ie "\\*([\\$1"\\*(]\\$1" \{\
.			key:nopun
.			idm:num +1 0
.			ie t .char £ \v"-0.25m"\D"l 1.5v 0"\v"0.25m"
.			el .char £ \(em
.			PI £
.			rchar £
.		\}
.		el .idm:PB
.		lang:char
.	\}
.	el .idm:PB
.	\}
..
.\""""""""""""""""""""""""""""""""""""""""""""""""
.\" op. cit.
.nr opc-trap 0 1
.de opc:text
.	\" We record the page number of the first occurence
.	\" of each reference in opc-\\*([K
.	if d [K \{\
.	ie r opc-\\*([K \{\
.		\" If this reference has been printed somewhere
.		ref:remove C D E G H I M N Q R
.		ref:remove U W X Y Z w x y z
.		\" If previous occurence is in the same page,
.		\" write hereinbefore
.		ie \\n[opc-\\*([K]=\\n% .ds [% \\*[lang-before]
.		\"  else, write p xx
.		el .ds [% \\*[lang-p]\~\\n[opc-\\*([K]
.	\}
.	el \{\
.		\" This is the first occurence of that reference
.		\" so, we record its page number in opc-\\*([K
.		\" we use a temporary definition for same page
.		\" occurences and use an output line trap
.		\" to get the correct page for next pages occurences
.		nr opc-\\*([K \\n%
.		lnr opc-tmp \\n[opc-trap]
.		de opc:trap\\n+[opc-trap]
.			\" the output line trap macro
.			nr opc-\\*([K \\En%
.			rm opc:trap\\n[opc-tmp]
\\..
.		\" the output line trap which will call the macro
.		var:print \\P[opc:trap\\n[opc-trap]]\\c
.	\}
.	\}
..
.als opc:coll var:null
.\"""""""""""""""""""""""""""""""""""""""""""""""
.\" idx
.de idx:text
.	\" index some key
.		\"if d [A .LN \\*([A
.		\"if d [E .LN \\*([E
.		if d [T .LT "\\*([T"
.		if d [B .LT "\\*([B"
.		if d [J .LT "\\*([J"
.		if d [S .LT "\\*([S"
..
.als idx:coll var:null
.\"""""""""""""""""""""""""""""""""""""""""""""""
.\" Print paragraph macros
.
.de ref:text-start
.	\" test if we print start note macro or not
.	ie \\n(RN .if \\n[note-in]=0 \{\
.		\" print the refereence in a note
.		\"var:print \\P[page:num]\\c
.		NS
.		nr note-inref 1
.	\}
.	\" print the note intext, inside []
.	el [\\c
..
.de ref:text-stop
.	\" test if we print stop note macro or not
.	ie \\n(RN .if \\n[note-inref]=1 \{\
.		\" print the refereence in a note
.		NE
.		nr note-inref 0
.	\}
.	\" print the note intext, inside []
.	el ]
..
.\" idem:coll do it better for collected references
.als ref:coll-start var:null
.als ref:coll-stop var:null
.\""""""""""""""""""""""""""""""""""""""""""""""""
.\" Refer macros
.de ref:rename
.	\" to check for idem references,
.	\" rename each fields from [X to ]X
.	while \\n(.$ \{\
.		if d ]\\$1 .rm ]\\$1
.		if d [\\$1 .rn [\\$1 ]\\$1
.		shift
.\}
..
.de ref:remove
.	\" remove unused fields
.	while \\n(.$ \{\
.		if d [\\$1 .rm [\\$1
.		shift
.	\}
..
.de ref:init
.	\" initialize variables
.	ds key-beg
.	if d key-field .rm key-field
.	ds key-end
.	ds key-pun
.	nr key-grp 0 \" check if keys are printed
.	nr ref-idm \\n(RI
.	nr key-do 1
.	ref:remove A B C D E G H h I J L M N O P
.	ref:remove p Q R S T U V W X Y Z w x y z
.	ref:remove %
.	nr [E 0
.	nr [A 0
..
.de ]-
.	\" initialize a reference
.	if \\n(RI \{\
.		ref:rename A B C D E G H h I J L M N O P
.		ref:rename p Q R S T U V W X Y Z w x y z
.	\}
.	ref:init
..
.ds ref-loc text
.	\" or coll for collected references
.de ][
.	\" print reference
.	\" refer provide the follow arguments:
.	\" if J, 		$1=1, $2 journal-article 
.	\" elif B,		$1=3, $2 article-in-book
.	\" elif G or R,	$1=4, $2 tech-report
.	\" elif I		$1=2, $2 book
.	\" else			$1=0, $2 other
.	nr ref-type \\$1
.	ref:\\*[ref-loc]-start
.	if \\n(RO .opc:\\*[ref-loc]
.	idx:\\*[ref-loc]
.	ref:\\*[ref-loc]-\\n[ref-type]
.	ref:\\*[ref-loc]-stop
..
.de ]<
.	\" start collected references
.	ref:init
.	ds ref-loc coll
.	H3 \\*[lang-bibliography]
.	\"H* \\*[lang-bibliography]
.	\"H0 \\*[lang-bibliography]
..
.de ]>
.	\" end collected references
.	ref:init
.	ds ref-loc text
..
.\" For philia from http://utroff.org
.als @ var:null
.\"""""""""""""""""""""""""""""""""""""""""""""""
.\" User macros
.de XB
.	\" Append bibliography list
.	\" need a special version of refer,
.	\" available on http://utroff.org
.	pso @BINDIR@/refer -i -B -a -dAE \\$1
..
.if !r RI .nr RI 1
.if !r RO .nr RO 1
.if !r RN .nr RN 1
.de RI
.	\" Reverse idem (first use will remove it)
.	nr RI 1-\\n(RI
..
.de RO
.	\" Reverse op. cit. (first use will remove it)
.	nr RO 1-\\n(RO
..
.de RN
.	\" Reverse usage of notes (first use will remove it)
.	nr RN 1-\\n(RN
..
